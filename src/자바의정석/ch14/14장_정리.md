[Notion Link](https://www.notion.so/14-Lambda-Stream-d13a89906c84419185d1c92706ab5b2b)

## 람다식이란? 람다식 작성하기

자바는 JDK1.8부터 함수형언어도 추가가 됐다.

### 람다식(Lambda Expression)

- 함수(메소드)를 간단한 식으로 표현하는 방법
- 익명함수(이름이 없는 함수
    
    ```java
    int max(int a, int b){
    		return a > b ? a : b
    }
    
    (int a, int b) -> { return a > b ? a : b; }
    ```
    
- 함수와 메소드의 차이
    - 근본적으로 동일하다, 함수는 일반적 용어, 메소드는 객체지향개념 용어
    - 함수는 클래스에 독립적, 메소드는 클래스에 종속적

### 람다식 작성

- 메서드 이름과 반환타입을 제거하고 `→` 을 `{}` 앞에 추가한다.
- 반환값이 있는 경우 식이나 값만 적고 return문 생략 가능
- 매개변수의 타입이 추론 가능하면 생략 가능(대부분의 경우 생략이 가능하다.)

### 주의사항

- 매개변수가 하나인 경우, `( )` 생략 가능(타입이 없을 때만)
- 블록 안의 문장이 하나뿐 일 때 `{ }` 생략 가능
- 하나뿐인 문장이 return문이면 괄호 생략 불가능

### 예시

| 메소드 | 람다식 |
| --- | --- |
| int max(int a, int b){
   return a > b ? a : b;
} | (a, b) → a > b ? a : b |
| int printVar(String anme, int i) {
    System.out.println(name + “ = “ + i)
} | (name, i) → System.out.println(name + “ = “ + i) |
| int square(int x){
   return x * x;
} | x → x * x |
| int roll(){
   return (int)(Math,random()*6);
} | () → (int)(Math.random()*6) |

### 람다식은 익명함수? 익명객체이다!

- 람다식은 익명함수가 아니라 익명 객체이다.
- 람다식을 다루기 위한 참조변수가 필요 참조 변수 타입은?
    
    ```java
    Object obj = (a, b) -> a > b ? a : b; // 어떤 타입이지?
    ```
    

```java
package 자바의정석.ch14;

public class Ex14_0 {
    public static void main(String[] args) {
//        Object obj = (a, b) -> a > b ? a : b; // 람다식은 익명객체이므로 이렇게 할 경우 오류가 생긴다.
        Object obj = new Object() {
            int max(int a, int b) {
                return a > b ? a : b;
            }
        };

//        int value = obj.max(3, 5); // Cannot resolve method 'max' in 'Object'
        // 위 같은 것을 해결하기 위해서 나온게 함수형 인터페이스이다.
    }
}
```

## 함수형 인터페이스

---

함수형인터페이란 단 하나의 추상 메서드만 선언된 인터페이스이다.

```java
@FunctionalInterface // 함수형 인터페이스가 제대로 됐는지 확인
interface MyFunction{
		public abstract int max(int a, int b);
}

MyFunciton f = new MyFunction(){
		public int max(int a, int b){
				return a > b ? a : b;
		}
};
```

```java
package 자바의정석.ch14;

public class Ex14_0 {
    public static void main(String[] args) {
//        Object obj = (a, b) -> a > b ? a : b; // 람다식은 익명객체이므로 이렇게 할 경우 오류가 생긴다.
        MyFunction mf = (a,b) -> a > b ? a : b;
        int value = mf.max(3, 5);
//        int value = obj.max(3, 5); // Cannot resolve method 'max' in 'Object'
        // 위 같은 것을 해결하기 위해서 나온게 함수형 인터페이스이다.
    }
}

@FunctionalInterface // 함수형 인터페이스는 단 하나의 추상 메서드만 갖고 간다.
interface MyFunction{
    public abstract int max(int a, int b);
}
```

### 함수형 인터페이스 예제

- 익명 객체를 람다식으로 대체
    
    ```java
    List<String> list = Arrays.asList("abc", "aaa", "bbb");
    /*Collections.sort(list, new Comparator<String>() {
        @Override
        public int compare(String o1, String o2) {
            return o2.compareTo(o1);
        }
    });*/
    // Lambda 식으로 변경
    Collections.sort(list, (s1, s2) -> s2.compareTo(s1));
    ```
    
- 함수형 인터페이스 타입의 매개변수

```java
package 자바의정석.ch14;

@FunctionalInterface
interface MyFunction {
    void run();  // public abstract void run();
}

class Ex14_1 {
    static void execute(MyFunction f) { // 매개변수의 타입이 MyFunction인 메서드
        f.run();
    }

    static MyFunction getMyFunction() { // 반환 타입이 MyFunction인 메서드
        return () -> System.out.println("f3.run()");
    }

    public static void main(String[] args) {
        // 람다식으로 MyFunction의 run()을 구현
        MyFunction f1 = ()-> System.out.println("f1.run()");

        // 직접 만들기
        MyFunction f2 = new MyFunction() {  // 익명클래스로 run()을 구현
            public void run() {   // public을 반드시 붙여야 함
                System.out.println("f2.run()");
            }
        };

        MyFunction f3 = getMyFunction();

        f1.run();
        f2.run();
        f3.run();

        execute(f1);
        execute( ()-> System.out.println("run()") );
    }
}
```

## java.tuil.function 패키지

---

### 자주 사용되는 다양한 함수형 인터페이스를 제공

| 함수형인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| java.lang.Runnable | void run() | 매개변수도 없고, 반환값도 없음  |
| Supplier<T> | T get() | 매개변수는 없고, 반환값만 있음  |
| Consumer<T> | void accept(T t) | 매개변수만 있고, 반환값이 없음 |
| Function<T, R> | R apply(T t) | 하나의 매개변수를 받아 결과를 반환 |
| Predicate<T> | boolean test(T t) | 조건식을 표현하는데 사용됨
매개변수는 하나, 반환 타입은 boolean |

```java
Predicate<String> isEmpty = s -> s.length() == 0;
  String s = "";
  if (isEmpty.test(s)) {
      System.out.println("비어이쓴ㄴ 공간입니다.");
  }
```

### 매개변수가 2개인 함수형 인터페이스

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| BiConsumer<T.U> | void accept(T t, U u) | 두 개의 매개변수만 있고, 반환값이 없음 |
| BiPredicate<T.U> | boolean test(T t, U u) | 조건식을 표현하는데 사용됨 반환값은 boolean |
| BiFunction<T.U.R> | R apply(T t, U u) | 두 개의 매개변수를 받아서 하나의 결과를 반환  |

**❓ 매개변수가 3개 이상 필요하다면?**

- 직접 만들어 쓰자.

### 매개변수 타입과 반환타입이 일치하는 함수형 인터페이스

| 함수형 인터페이스 | 메소드 | 설명 |
| --- | --- | --- |
| UnaryOperator<T> | T apply(T t) | Function의 자손, FUnction과 달리 매개변수와 결과의 타입이 같다. |
| BinaryOperator<T> | T appley(T t, T t) | BiFunction의 자손 |

```java
package 자바의정석.ch14;

import java.util.function.*;
import java.util.*;

class Ex14_2 {
    public static void main(String[] args) {
        Supplier<Integer> s = () -> (int) (Math.random() * 100) + 1;
        Consumer<Integer> c = i -> System.out.print(i + ", ");
        Predicate<Integer> p = i -> i % 2 == 0;
        Function<Integer, Integer> f = i -> i / 10 * 10;

        List<Integer> list = new ArrayList<>();
        makeRandomList(s, list);
        System.out.println(list);
        printEvenNum(p, c, list); // 짝수 출력
        List<Integer> newList = doSomething(f, list);
        System.out.println(newList);
    }

//    Function<Integer, Integer> f = i -> i / 10 * 10;
    static <T> List<T> doSomething(Function<T, T> f, List<T> list) {
        List<T> newList = new ArrayList<T>(list.size());

        for(T i : list) {
            newList.add(f.apply(i));
        }

        return newList;
    }

//    Consumer<Integer> c = i -> System.out.print(i + ", ");
//    Predicate<Integer> p = i -> i % 2 == 0;
    static <T> void printEvenNum(Predicate<T> p, Consumer<T> c, List<T> list) {
        System.out.print("[");
        for(T i : list) {
            if(p.test(i)) // 짝수인지 검사
                c.accept(i);
        }
        System.out.println("]");
    }
//    Supplier<Integer> s = () -> (int) (Math.random() * 100) + 1;
    static <T> void makeRandomList(Supplier<T> s, List<T> list) {
        for(int i=0;i<10;i++) {
            list.add(s.get()); // 공급자로부터 1 ~ 100 사이의 난수 받음
        }
    }
}

[13, 95, 44, 92, 84, 93, 81, 26, 24, 53]
[44, 92, 84, 26, 24, ]
[10, 90, 40, 90, 80, 90, 80, 20, 20, 50]
```

## Predicate의 결합, CF와 함수형 인터페이스

---

### Predicate의 결합

- and(), or(), negate() → not
- 두 Predicate를 하나로 결합(default 메소드)
- 등가비교를 위한 Predicate의 작성에는 isEqual()을 사용(static 메소드)

```java
package 자바의정석.ch14;

import java.util.function.*;

class Ex14_3 {
    public static void main(String[] args) {
        // 16진수로 변환
        Function<String, Integer>	f  = (s) -> Integer.parseInt(s, 16);
        // 2진수로 변환
        Function<Integer, String>	g  = (i) -> Integer.toBinaryString(i);

        // function 하나로 합치기
        Function<String, String>    h  = f.andThen(g);
        // f에서 String이 들어가서 Integer가 나온다.
        // g에서 Integer이 들어와서 String이 나온다.
        // 즉 합칠려면 앞에꺼 출력이 뒤에꺼 입력과 타입이 같아야만 한다.

        Function<Integer, Integer>  h2 = f.compose(g); // g.andThen(f)

        System.out.println(h.apply("FF")); // "FF" → 255 → "11111111"
        System.out.println(h2.apply(2));   // 2 → "10" → 16

        // x가 들어가면 x가 나온다.
        Function<String, String> f2 = x -> x; // 항등 함수(identity function)
        System.out.println(f2.apply("AAA"));  // AAA가 그대로 출력됨

        Predicate<Integer> p = i -> i < 100;
        Predicate<Integer> q = i -> i < 200;
        Predicate<Integer> r = i -> i % 2 == 0;

        Predicate<Integer> notP = p.negate();        // !(i < 100)-> i >= 100
        Predicate<Integer> all = notP.and(q).or(r);  // i >= 100 && i < 200 || i % 2 == 0
        Predicate<Integer> all2 = notP.and(q.or(r)); // i >= 100 && (i < 200 || i % 2 == 0)
        System.out.println("all.test(150) = " + all.test(150)); // true
        System.out.println("all2.test(200) = " + all.test(251)); // false

        String str1 = "abc";
        String str2 = "abc";

        // str1과 str2가 같은지 비교한 결과를 반환
        Predicate<String> p2 = Predicate.isEqual(str1);
        boolean result = p2.test(str2);
        System.out.println(result);
    }
}

11111111
16
AAA
all.test(150) = true
all2.test(200) = false
true
```

### 컬렉션 프레임워크와 함수형 인터페이스

| 인터페이스 | 메서드 | 설명 |
| --- | --- | --- |
| Collection | boolean removeIf(Predicate<T> filter) | filter 조건의 element 제거 |
| List | void replaceAll(UnaryOperator<T> operator) | 모든 element를 operator 수행 결과로 반환 |
| Iterable | void forEach(Consumer<T> action) | 모든 element에 대해 action 수행 |
| Map | V compute(K key, BiFunction<K, V, V> f) | 특정 key에 대해 f 수행 |
| Map | V computeIfAbsent(K key, Function<K, V> f) | 특정 key가 없을 경우 f 수행 후 추가 |
| Map | V computeIfPresent(K key, BiFunction<K, V, V> f) | 특정 key가 있을 경우 f 수행 후 반환 |
| Map | V merge(K key, V value, BiFunction<V, V, V> f) | 특정 key에 대해 f 병합 수행 |
| Map | void forEach(BiConsumer<K, V> action) | 모든 element에 대해 action 수행 |
| Map | void replaceAll(BiFunction<K, V, V> f) | 모든 element에 대해 f 수행 결과로 반환 |

```java
package 자바의정석.ch14;

import java.util.*;

class Ex14_4 {
    public static void main(String[] args) 	{
        ArrayList<Integer> list = new ArrayList<>();
        for(int i=0;i<10;i++)
            list.add(i);

        // list의 모든 요소를 출력
        list.forEach(i -> System.out.print(i + ","));
        System.out.println();

        // list에서 2 또는 3의 배수를 제거한다.
        System.out.println("2, 3의 배수 제거");
        list.removeIf(x -> x % 2 == 0 || x % 3 == 0);
        System.out.println(list);

        System.out.println("각 요소 10 곱하기");
        list.replaceAll(i->i*10); // list의 각 요소에 10을 곱한다.
        System.out.println(list);

        Map<String, String> map = new HashMap<>();
        map.put("1", "1");
        map.put("2", "2");
        map.put("3", "2");
        map.put("4", "2");
        map.put("5", "3");
        map.put("6", "4");

        // map의 모든 요소를 {k,v}의 형식으로 출력한다.
        System.out.println("map의 모둔 요소 출력");
        map.forEach((k, v) -> System.out.print("{" + k + "," + v + "},"));
        ArrayList<String> arr = new ArrayList<>();
        // value가 2인 k값 추가 하는 방법
        map.forEach((k, v) -> {
            if(v.equals("2"))
                arr.add(k);
        });
        System.out.println();
        arr.forEach(i -> System.out.print(i + " "));
        arr.forEach(System.out::println);
    }
}
```

## 메소드의 참조, 생성자 메소드 참조

---

하나의 메소드만 호출하는 람다식은 메소드 참조로 간단히 할 수 있다.

| 종류 | 람다 | 메소드 참조 |
| --- | --- | --- |
| static 메소드 참조  | (x) → ClassName.method(x) | ClassName::method |
| 인스턴스 메소드 참조 | (obj.x) → obj.method(x) | ClassName::method |
- 생성자와 메소드 참조
    
    ```java
    Supplier<MyClass> s = () -> new MyClass();
    Supplier<MyClass> s = MyClass::new;
    ```
    
- 배열과 메소드 참조
    
    ```java
    Function<Integer, int[]> f = x -> new int[x];
    Function<Integer, int[]> f = int[]::new;
    ```
    

```java
package 자바의정석.ch14;

import com.google.common.base.Function;
import com.google.common.base.Supplier;

public class Ex14_0 {
    public static void main(String[] args) {
//        Supplier<MyClass> s = () -> new MyClass();
//        Supplier<MyClass> s = MyClass::new;
//        Function<Integer, MyClass> s = (i) -> new MyClass(i);
        Function<Integer, MyClass> s = MyClass::new;

        MyClass mc = s.apply(100);
        System.out.println("mc.iv = " + mc.iv);
        System.out.println("s.apply(200).iv = " + s.apply(200).iv);

        Function<Integer, int[]> f = (i) -> new int[i];
        System.out.println("f.apply 배열 길이 : " + f.apply(100).length);
    }
}

class MyClass {
    int iv;

    public MyClass(int iv) {
        this.iv = iv;
    }
}
```

## 스트림, 스트림의 특징

---

다양한 데이터 소스(컬렉션, 배열)을 표준화된 방법으로 다루기 위한 것

스트림 만들기 → 중간 연산 → 최종 연산 → 결과

[**Stream**](https://www.notion.so/Stream-f50966b640ac45789335f3c52907d489)

### 스트림의 특징

- 스트림은 데이터 소스로부터 데이터를 읽기만 할 뿐 변경하지 않는다.
    
    ```java
    List<String> list = Arrays.asList("yonsangu", "seoul");
    
    Stream<String> stringStream = list.stream().map(String::toUpperCase); // 소문자를 대문자로 바꿔보기
    
    System.out.println("---------대문자로 바꿔서 Stream 내용 출력---------");
    stringStream.forEach(System.out::println);
    System.out.println("---------원본 List 출력---------");
    list.forEach(System.out::println);
    
    /* 출력 결과
     * ---------대문자로 바꿔서 Stream 내용 출력---------
     * YONSANGU
     * SEOUL
     * ---------원본 List 출력---------
     * yonsangu
     * seoul
     */
    ```
    
- Iterator 처럼 일회용이다.(필요하면 다시 스트림을 생성해야 함)
- 최종연산 전까지 중간연산이 수행되지 않는다. - 지연된 연산
- 작업을 내부 반복으로 처리한다.
- 작업을 병렬로 처리한다. - 병렬 스트림
    
    ```java
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Lee", "Ji", "Hoon");
    
        List<String> collect = names.parallelStream().map(s -> {
            System.out.println(s + " " + Thread.currentThread().getName());
            return s.toUpperCase();
        }).collect(Collectors.toList());
    
        collect.forEach(System.out::println);
    }
    ```
    
    하지만 멀티 스레드를 이용한다고 성능이 무조건 좋아지는 것은 아니며, 오히려 느려질 수도 있기에 기본 `Stream`을 쓰는 것을 권장하며 성능 테스트 후 `parallelStream()` 사용을 권장한다.
    
- 기본형 스트림 - IntStream, LongStream, DoubleStream
    - 오토박싱 언박싱의 비효율이 제거됨 (Stream<Integer> 대신 IntStream 사용)
    - 숫자와 관련된 유용한 메서드를 Stream<T> 보다 더 많이 제공됨

## 스트림 만들기

---

### 스트림 만들기 - 컬렉션

- Collection 인터페이스의 stream()으로 컬렉션을 스트림으로 변환
    
    ```java
    Stream<E> stream() // Collection 인터페이스의 메소드
    
    List<Integer> list = Arrays.asList(1, 2, 3);
    Stream<Integer> intStream = list.stream(); // list를 stream으로 변환
    
    intStream.forEach(System.out::println);
    
    // 다시 사용하고 싶으면 재생성 해줘야 한다.
    intStream = list.stream();
    // 이미 사용한 스트림은 재사용할 수 없다.
    intStream.forEach(System.out::println);
    ```
    
- 객체 배열로부터 스트림 생성하기
    
    ```java
    Stream<String> strStream1 = Stream.of("a", "b", "c");
    Stream<String> strStream2 = Stream.of(new String[]{"a", "b", "c"});
    Stream<String> strStream3 = Arrays.stream(new String[]{"a", "b", "c"});
    Stream<String> strStream4 = Arrays.stream(new String[]{"a", "b", "c"}, 0, 2);
    System.out.println("0번 인덱스부터 1번 인덱스 까지");
    strStream4.forEach(System.out::println);
    
    0번 인덱스부터 1번 인덱스 까지
    a
    b
    ```
    
- 기본형 배열로부터 스트림 생성하기
    
    ```java
    int[] arr = {1, 2, 3, 4};
    IntStream intStream = Arrays.stream(arr);
    System.out.println("intStream.sum() = " + intStream.sum()); // 최종연산
    intStream = Arrays.stream(arr); // 새로 생성
    System.out.println("intStream.count() = " + intStream.count()); // 최종연산
    intStream = Arrays.stream(arr); // 새로 생성
    System.out.println("intStream.average() = " + intStream.average()); // 최종연산
    
    intStream.sum() = 10
    intStream.count() = 4
    intStream.average() = OptionalDouble[2.5]
    ```
    

### 스트림 만들기 - 임의의 수(난수)

```java
IntStream intStream = new Random().ints(5, 10);
intStream.limit(5).forEach(System.out::println);
```

### 스트림 만들기 - 특정 범위의 정수

```java
IntStream range = IntStream.range(10, 20);
range.forEach(System.out::println);
```

### 스트림 만들기 - 람다식 iterate(), generate()

- 람다식을 소스로 하는 스트림 생성하기
- iterate()는 이전 요소를 seed로 해서 다음 요소를 계산한다.
- generate()는 seed를 사용하지 않는다.

```java
public static void main(String[] args) {

    // iterate(T seed, UnaryOperator f) 단항 연산자
    Stream<Integer> intStream = Stream.iterate(0, n -> n + 2);
    intStream.limit(10)
            .forEach(System.out::println);

    // generate(Supplier s) : 주기만 하는 것 입력x 출력o
    Stream<Integer> oneStream = Stream.generate(() -> 1);
    oneStream.limit(10)
            .forEach(System.out::println);
}
```

### 스트림 만들기 - 파일과 빈 스트림

- 파일을 소스로 하는 스트림 생성하기

```java
* 파일을 소스로 하는 스트림 생성하기 : 
Stream<Path> Files.list(Path dir) // Path는 파일 또는 디렉토리
Stream<String> Files.lines(Path path)
Stream<String> Files.lines(Path path, Charset cs)
Stream<String> lines() // BufferedReader클래스의 메서드
* 비어있는 스트림 생성
Stream emptyStream = Stream.empty(); // empty()는 빈 스트림을 생성해서 반환
long count = emptyStream.count() // count 값은 0
```

## 스트림의 연산

---

스트림이 제공하는 기능 - 중간 연산과 최종 연산

### 중간연산

- Stream<T> distinct()        중복을 제거
- Stream<T> filter(Predicate<T> predicate)     조건에 안 맞는 요소 제외
- Stream<T> limit (long maxSize)         스트림의 일부를 잘라낸다
- Stream<T> skip(long n)        스트림의 일부를 건너뛴다.
- Stream<T> peek(Consumer<T> action)     스트림의 요소에 작업을 수행
- 스트림의 요소를 정렬한다.
    - Stream<T> sorted()
    - Stream<T> sorted(Comparator<T> comparator)

### 스트림의 요소를 변환

- **Stream<R> map(Function<T,R> mapper)**
- DoubleStream mapToDouble(ToDoubleFunction<T> mapper)
- **IntStream mapToInt(ToIntFunction<T> mapper)**
- LongStream mapToLong(ToLongFunction<T> mapper)
- **Stream<R> flatMap(Function<T,Stream<R>> mapper)**
- DoubleStream flatMapToDouble(Function<T.DoubleStream> m)
- IntStream flatMapToInt(Function<T, IntStream> m)
- LongStream flatMapToLong(Function<T,LongStream> m)

### 최종연산

- 각 요소에 지정된 작업 수행
    - void forEach(Consumer<? super T> action>
    - void forEachOrdered(Consumer<? super T>action)
- 스트림의 요소의 개수 반환
    - long count()
- 스트림의 최대값/최소값을 반환
    - Optional<T> max (Comparator<? super T> comparator)
    - Optional<T> min (Comparator<? super T> comparator)
- 스트림의 요소 하나를 반환
    - Optional<T> findAny() //아무거나 하나
    - Optional<T> findFirst() //첫번째 요소
- 주어진 조건을 모든 요소가 만족시키는지, 만족시키지 않는지 확인
    - boolean allMatch(Predicate<T> p) //모두 만족 하는지
    - boolean anyMatch(PredicaAte<T> p ) //하나라도 만족하는지
    - boolean nonMatch(Predicate<> p) //모두 만족하지 않는지
- 스트림의 모든 요소를 배열로 반환
    - Object[] toArray()
    - A[] toArray(IntFunction<A[]> generator)
    - 스트림의 요소를 하나씩 줄여가면서(리듀싱) 계산한다.
    - Optional<T> reduce(BinaryOperator<T> accumulator)
    - T reduce (T identity, BinaryOperator<T> accumulator)
    - U reduce (U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U> combiner)
- 스트림의 요소를 수집한다. 주로 요소를 그룹화하거나 분할한 결과를 컬렉션에 담아 반환하는데 사용된다.
    - R collect(Collector<T,A,R> collector)
    - R collect(Supplier<R> supplier, BiConsumer<R,T> accumulator, BiConsumer<R,R> combiner

## 스트림의 중간연산

- 스트림 자르기 - skip(), limit()
    
    ```java
    IntStream intStream = IntStream.rangeClosed(1, 10);// 1 ~10 포함
            intStream.skip(3) // 0 ~ 3번째 인덱스까지 skip
                    .limit(5) // 5개만 출력
                    .forEach(System.out::println);
    4
    5
    6
    7
    8
    ```
    
- 스트림의 요소 걸러내기 - filter(), distinct()
    
    ```java
    IntStream intStream = IntStream.range(1, 11);
    intStream.filter(i -> i % 2 == 0) // 여러개도 가능하다.
                    .forEach(System.out::println);
    2
    4
    6
    8
    10
    ```
    
- 스트림 정렬하기
    - 정렬을 할 때는 정렬 대상과 기준이 필요하다.
    
    ```java
    package 자바의정석.ch14;
    
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.List;
    import java.util.Random;
    import java.util.stream.IntStream;
    import java.util.stream.Stream;
    
    public class Example {
        public static void main(String[] args) {
            ArrayList<Student> studentArrayList = new ArrayList<>();
            studentArrayList.add(new Student(10, "홍길동"));
            studentArrayList.add(new Student(20, "길영이"));
            studentArrayList.add(new Student(40, "우영우2"));
            studentArrayList.add(new Student(40, "우영우"));
            studentArrayList.add(new Student(30, "정변"));
    
            Stream<Student> string = studentArrayList.stream();
            string.sorted((s1, s2) -> s1.age < s2.age ? 1 : (s1.age == s2.age ? 0 : -1))
                    .forEach(student -> {
                        System.out.println("student.age = " + student.age);
                        System.out.println("student.name = " + student.name);
                    });
        }
    }
    class Student{
        int age;
        String name;
    
        public Student(int age, String name) {
            this.age = age;
            this.name = name;
        }
    }
    student.age = 40
    student.name = 우영우2
    student.age = 40
    student.name = 우영우
    student.age = 30
    student.name = 정변
    student.age = 20
    student.name = 길영이
    student.age = 10
    student.name = 홍길동
    ```
    
- Compartor의 comparing()으로 정렬 기준을 제공
- 추가 정렬 기준을 제공할 때는 thenComparing()을 사용
    
    ```java
    package 자바의정석.ch14;
    import java.util.*;
    import java.util.stream.*;
    
    class Ex14_5 {
        public static void main(String[] args) {
            Stream<Student> studentStream = Stream.of(
                    new Student("이자바", 3, 300),
                    new Student("김자바", 1, 200),
                    new Student("안자바", 2, 100),
                    new Student("박자바", 2, 150),
                    new Student("소자바", 1, 200),
                    new Student("나자바", 3, 290),
                    new Student("감자바", 3, 180)
            );
    
    //        studentStream.sorted(Comparator.comparing(Student::getBan) // 반별 정렬
    //                        // 기본 정렬 즉 원래 compareTo가 작동
    //                        // 내림차순은 reversed를 해준다.
    //                        .thenComparing(Comparator.naturalOrder()))
    //                        .forEach(System.out::println);
            studentStream.sorted(Comparator.comparing((Student s) -> s.getBan())
                    .thenComparing(Comparator.comparing((Student s2) -> s2.getTotalScore())))
                    .forEach(System.out::println);
    
        }
    }
    
    class Student implements Comparable<Student> {
        String name;
        int ban;
        int totalScore;
        Student(String name, int ban, int totalScore) {
            this.name =name;
            this.ban =ban;
            this.totalScore =totalScore;
        }
    
        public String toString() {
            return String.format("[%s, %d, %d]", name, ban, totalScore);
        }
    
        String getName()     { return name;}
        int getBan()         { return ban;}
        int getTotalScore()  { return totalScore;}
    
        // 총점 내림차순을 기본 정렬로 한다.
        public int compareTo(Student s) {
            return s.totalScore - this.totalScore;
        }
    }
    ```
    
- 스트림의 요소 반환하기 - map()
    
    ```java
    package 자바의정석.ch14;
    
    import java.io.*;
    import java.util.stream.*;
    
    class Ex14_6 {
        public static void main(String[] args) {
            File[] fileArr = {new File("Ex1.java"), new File("Ex1.bak"),
                    new File("Ex2.java"), new File("Ex1"), new File("Ex1.txt")
            };
    
            Stream<File> fileStream = Stream.of(fileArr);
    
            // map()으로 Stream<File>을 Stream<String>으로 변환
            Stream<String> filenameStream = fileStream.map((file -> file.getName()));
            filenameStream.forEach(System.out::println); // 모든 파일의 이름을 출력
    
            fileStream = Stream.of(fileArr);  // 스트림을 다시 생성
    
            System.out.println("======확장자만 추출해서 대문자로 변환 후 중복제거하기======");
            fileStream.map(file -> file.getName())     // Stream<File> → Stream<String>
                    .filter(s -> s.indexOf('.')!=-1)   // 확장자가 없는 것은 제외
                    .map(s -> s.substring(s.indexOf('.')+1)) // 확장자만 추출
                    .map(String::toUpperCase)     // 모두 대문자로 변환
                    .distinct()                   //  중복 제거
                    .forEach(System.out::println);  // JAVABAKTXT
    
            System.out.println();
        }
    }
    Ex1.java
    Ex1.bak
    Ex2.java
    Ex1
    Ex1.txt
    ======확장자만 추출해서 대문자로 변환 후 중복제거하기======
    JAVA
    BAK
    TXT
    ```
    
- 스트림의 요소를 소비하지 않고 엿보기 - peek()
    
    ```java
    System.out.println("======확장자만 추출해서 대문자로 변환 후 중복제거하기======");
    fileStream.map(file -> file.getName())     // Stream<File> → Stream<String>
            .filter(s -> s.indexOf('.')!=-1)   // 확장자가 없는 것은 제외
            .peek(s -> System.out.printf("확장자들 추출 전 확인 : filename = %s%n", s))
            .map(s -> s.substring(s.indexOf('.')+1)) // 확장자만 추출
            .map(String::toUpperCase)     // 모두 대문자로 변환
            .peek(s -> System.out.printf("대문자로 변환 됐는지 확인 : filename = %s%n", s)) //
            .distinct()                   //  중복 제거
            .forEach(System.out::println);  // JAVABAKTXT
    
    ======확장자만 추출해서 대문자로 변환 후 중복제거하기======
    확장자들 추출 전 확인 : filename = Ex1.java
    대문자로 변환 됐는지 확인 : filename = JAVA
    JAVA
    확장자들 추출 전 확인 : filename = Ex1.bak
    대문자로 변환 됐는지 확인 : filename = BAK
    BAK
    확장자들 추출 전 확인 : filename = Ex2.java
    대문자로 변환 됐는지 확인 : filename = JAVA
    확장자들 추출 전 확인 : filename = Ex1.txt
    대문자로 변환 됐는지 확인 : filename = TXT
    TXT
    ```
    
- 스트림의 스트림을 스트림으로 변환
    
    ```java
    package 자바의정석.ch14;
    import java.util.*;
    import java.util.stream.*;
    
    class Ex14_7 {
        public static void main(String[] args) {
            Stream<String[]> strArrStrm = Stream.of(
                    new String[]{"abc", "def", "jkl"},
                    new String[]{"ABC", "GHI", "JKL"}
            );
    
    //		Stream<Stream<String>> strStrmStrm = strArrStrm.map(Arrays::stream);
            Stream<String> strStrm = strArrStrm.flatMap(Arrays::stream);
    
            strStrm.map(String::toLowerCase) // 소문자
                    .distinct() // 중복제거
                    .sorted() // 정렬
                    .forEach(System.out::println);
            System.out.println();
    
            String[] lineArr = {
                    "Believe or not It is true",
                    "Do or do not There is no try",
            };
    
            Stream<String> lineStream = Arrays.stream(lineArr);
            lineStream.flatMap(line -> Stream.of(line.split(" +"))) // 하나 이상의 공백
                    .map(String::toLowerCase)
                    .distinct()
                    .sorted()
                    .forEach(System.out::println);
            System.out.println();
        }
    }
    abc
    def
    ghi
    jkl
    
    believe
    do
    is
    it
    no
    not
    or
    there
    true
    try
    ```
    

## Optional

---

T타입 객체의 래퍼 클래스 - Optional<T>

**❓ 왜 사용할까?**

주로 간접적으로 null을 다루기 위해서 사용한다.

- null을 직접 다루는 것은 위험하다 (NPE)
- null 체크를 좀 더 간편하게 하기 위해서
    
    
### Optinal<T> 객체 생성하기

```java
String str = "abc";
Optional<String> optVal1 = Optional.of(str);
Optional<String> optVal2 = Optional.of("abc");
Optional<String> optVal3 = Optional.of(null);  // NPE 발생
Optional<String> optVal4 = Optional.ofNullable(null);  // 가능
```

- null 대신 빈 Optinal<T> 객체를 사용하자.

### Optional<T> 객체의 값 가져오기

- get(), orElse(), orElseGet(), orElseThrow()
    
    ```java
    String str = "abc";
    Optional<String> optVal1 = Optional.of(str);
    String str1 = optVal1.get(); // null이면 예외 발생
    String str2 = optVal1.orElse(""); //null이면 "" 반환
    String str3 = optVal1.orElseGet(String::new); // 람다식 사용 가능 -> new String
    String str4 = optVal1.orElseThrow(NullPointerException::new);
    ```
    
- isPresent() - Optinal 객체의 값이 null이면 false 아니면 true를 반환
    
    ```java
    String str = new String("가나다");
            // if(str!=null)
            if(Optional.ofNullable(str).isPresent())
                System.out.println(str);
    ```
    

```java
//        Optional<String> opt = null; // OK 바람직하지는 않다.
Optional<String> opt = Optional.empty();
//        System.out.println("opt = " + opt.get()); // No value present
System.out.println(opt.orElse("빈문자열이였습니다.")); // 빈문자열이였습니다.
System.out.println(opt.orElseGet(() -> "빈문자열입니다.")); // 빈문자열이였습니다.
```

### OptinalIn, OptinalLong, OptinalDouble

- 기본형 값을 감싸는 래퍼 클래스
- OptinalInt의 값 가져오기 - int getAsInt()
- 빈 Optinal 객체와의 비교

```java
package 자바의정석.ch14;

import java.util.*;

class Ex14_8 {
    public static void main(String[] args) {
        Optional<String>  optStr = Optional.of("abcde");
        Optional<Integer> optInt = optStr.map(s -> s.length());
        System.out.println("optStr=" + optStr.get());
        System.out.println("optInt=" + optInt.get());

        int result1 = Optional.of("123")
                .filter(x -> x.length() > 0)
                .map(Integer::parseInt).get();

        int result2 = Optional.of("")
                .filter(x -> x.length() > 0)
                .map(Integer::parseInt).orElse(-1);

        System.out.println("result1=" + result1);
        System.out.println("result2=" + result2);

        Optional.of("456").map(Integer::parseInt)
                .ifPresent(x -> System.out.printf("result3=%d%n", x));

        OptionalInt opt = OptionalInt.of(0); // 0을 저장
        OptionalInt opt2 = OptionalInt.empty(); // 빈값인 0을 저장
        // 위 opt opt2를 어떻게 비교하기?
        // isPresent로 비교!
        System.out.println(opt.isPresent()); // true
        System.out.println(opt2.isPresent()); // false
        System.out.println(opt.getAsInt());  // 0

//		System.out.println(optInt2.getAsInt());  // NoSuchElementException
        System.out.println("optInt1=" + opt);
        System.out.println("optInt2=" + opt2);
        System.out.println("optInt1.equals(optInt2)?" + opt.equals(opt2));
    }
}
```

## 스트림의 최종연산

---

### forEach()

forEach(), forEachOrdered

parallel을 붙여 벙렬 스트림으로 가능하다.

```java
IntStream.range(1, 10)
          .parallel()
          .forEach(System.out::println); // 순서 보장이 안된다.

IntStream.range(1, 10)
        .parallel()
        .forEachOrdered(System.out::println); // 순서 보장을 위해서
```

### 조건검사

- allMatch(), anyMatch(), noneMatch()
    
    ```java
    allMatch() -> 모든 요소가 조건을 만족하면 true
    anyMatch() -> 한 요소라도 반족하면 true
    allMatch() -> 모든 요소가 조건을 만족하지 않으면 true
    ```
    
- 조건에 일치하는 요소 찾기 - findFirst), findAny()
    
    ```java
    findFirst() -> 첫 번째 요소를 반환 (순차 스트림에서 주로 사용)
    findAny() -> 아무거나 하나(병렬 스트림)
    ```
    

### reduce() → 제일 중요

스트림의 요소를 하나씩 줄여가며 누적연산을 수행 

```java
reduece(초기값, 이전 연산 결과와 스트림의 요소에 수행할 연산, 병렬처리된 결과를 합치는데 사용할 연산)
```

```java
package 자바의정석.ch14;

import java.util.*;
import java.util.stream.*;

class Ex14_9 {
    public static void main(String[] args) {
        String[] strArr = {
                "Inheritance", "Java", "Lambda", "stream",
                "OptionalDouble", "IntStream", "count", "sum"
        };

        Stream.of(strArr)
                .parallel() // 병렬 처리할 경우 여러 쓰레드가 나눠서 쓰기 때문에 요소 순서가 바뀌게 된다.
                .forEachOrdered(System.out::println); // 병렬처리를 하더라도 순서를 유지하고 싶으면 forEachOrdered
        boolean noEmptyStr = Stream.of(strArr)
                .noneMatch(s -> s.length() == 0); // 문자열 길이가 0인게 있나?

        Optional<String> sWord = Stream.of(strArr)
                .filter(s -> s.charAt(0) == 's') // 문자열 시작이 s인 것들만
                .findFirst();  // 첫 번째값만 반환

        System.out.println();
        System.out.println("noEmptyStr=" + noEmptyStr);
        System.out.println("sWord=" + sWord.get());

        // Stream<String>을 IntStream 으로 변환 -> mapToInt
        IntStream intStream1 = Stream.of(strArr).mapToInt(String::length);
        IntStream intStream2 = Stream.of(strArr).mapToInt(String::length);
        IntStream intStream3 = Stream.of(strArr).mapToInt(String::length);
        IntStream intStream4 = Stream.of(strArr).mapToInt(String::length);

        int count = intStream1.reduce(0, (a,b) -> a + 1);
        int sum   = intStream2.reduce(0, (a,b) -> a + b);

        OptionalInt max = intStream3.reduce(Integer::max);
        OptionalInt min = intStream4.reduce(Integer::min);
        System.out.println("count="+count);
        System.out.println("sum="+sum);
        System.out.println("max="+ max.getAsInt());
        System.out.println("min="+ min.getAsInt());
    }
}
Inheritance
Java
Lambda
stream
OptionalDouble
IntStream
count
sum

noEmptyStr=true
sWord=stream

count=8
sum=58
max=14
min=3
```

## Collect()와 Collectors()

---

- collect()는 Collector를 매개변수로 하는 스트림의 최종 연산
- Collector는 수집에 필요한 메서드를 정의해 놓은 인터페이스
- Collectors 클래스는 다양한 기능의 컬렉터를 제공해준다.

### 스트림을 컬렉션 배열로 변환

- toList(), toSet(), toMap(), toCollection()
- 스트림을 배열로 전환 - toArray

### 스트림의 통계 - counting(), summingInt()

- 스트림의 통계 정보 제공 - counting(), summingInt(), mayBy(), minBy()

### 스트림을 리듀싱 - reducing()

- 스트림을 리듀싱 이전에 reduce와 똑같은 역할을 한다.
    - reduece()는 전체 리듀싱이다.
    - reducing은 그룹별로 가능하다.
- 문자열 스트림의 요소를 모두 연결 - joining()

## 스트림의 그룹화와 분할

---

- partitioningBy()은 스트림을 2분할한다.
- gtoupingBy()는 스트림을 n분할한다.

```java
package 자바의정석.ch14;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import static java.util.stream.Collectors.*;
import static java.util.Comparator.*;

class Student2 {
    String name;
    boolean isMale; // 성별
    int hak;        // 학년
    int ban;        // 반
    int score;

    Student2(String name, boolean isMale, int hak, int ban, int score) {
        this.name	= name;
        this.isMale	= isMale;
        this.hak	= hak;
        this.ban	= ban;
        this.score  = score;
    }
    String	getName()    { return name;	}
    boolean  isMale()     { return isMale;	}
    int      getHak()     { return hak;	}
    int      getBan()     { return ban;	}
    int      getScore()   { return score;	}

    public String toString() {
        return String.format("[%s, %s, %d학년 %d반, %3d점]",
                name, isMale ? "남":"여", hak, ban, score);
    }
    // groupingBy()에서 사용
    enum Level { HIGH, MID, LOW }  // 성적을 상, 중, 하 세 단계로 분류
}

class Ex14_10 {
    public static void main(String[] args) {
        Student2[] stuArr = {
                new Student2("나자바", true,  1, 1, 300),
                new Student2("김지미", false, 1, 1, 250),
                new Student2("김자바", true,  1, 1, 200),
                new Student2("이지미", false, 1, 2, 150),
                new Student2("남자바", true,  1, 2, 100),
                new Student2("안지미", false, 1, 2,  50),
                new Student2("황지미", false, 1, 3, 100),
                new Student2("강지미", false, 1, 3, 150),
                new Student2("이자바", true,  1, 3, 200),
                new Student2("나자바", true,  2, 1, 300),
                new Student2("김지미", false, 2, 1, 250),
                new Student2("김자바", true,  2, 1, 200),
                new Student2("이지미", false, 2, 2, 150),
                new Student2("남자바", true,  2, 2, 100),
                new Student2("안지미", false, 2, 2,  50),
                new Student2("황지미", false, 2, 3, 100),
                new Student2("강지미", false, 2, 3, 150),
                new Student2("이자바", true,  2, 3, 200)
        };

        System.out.printf("1. 단순분할(성별로 분할)%n");
        Map<Boolean, List<Student2>> stuBySex = Stream.of(stuArr)
                .collect(partitioningBy(s -> s.isMale));

        List<Student2> maleStudent   = stuBySex.get(true);
        List<Student2> femaleStudent = stuBySex.get(false);

        System.out.println("1-1. 남자만 출력");
        for(Student2 s : maleStudent)   System.out.println(s);
        System.out.println("1-2. 여자만 출력");
        for(Student2 s : femaleStudent) System.out.println(s);

        System.out.printf("%n2. 단순분할 + 통계(성별 학생수)%n");
        Map<Boolean, Long> stuNumBySex = Stream.of(stuArr)
                .collect(partitioningBy(Student2::isMale, counting()));

        System.out.println("남학생 수 :"+ stuNumBySex.get(true));
        System.out.println("여학생 수 :"+ stuNumBySex.get(false));

        System.out.printf("%n3. 단순분할 + 통계(성별 1등)%n");
        Map<Boolean, Optional<Student2>> topScoreBySex = Stream.of(stuArr)
                .collect(partitioningBy(Student2::isMale,
                        maxBy(comparingInt(Student2::getScore))
                ));
        System.out.println("남학생 1등 :"+ topScoreBySex.get(true));
        System.out.println("여학생 1등 :"+ topScoreBySex.get(false));

        Map<Boolean, Student2> topScoreBySex2 = Stream.of(stuArr)
                .collect(partitioningBy(Student2::isMale,
                        collectingAndThen(
                                maxBy(comparingInt(Student2::getScore)), Optional::get
                        )
                ));

        System.out.println("남학생 1등 :"+ topScoreBySex2.get(true));
        System.out.println("여학생 1등 :"+ topScoreBySex2.get(false));

        System.out.printf("%n4. 다중분할(성별 불합격자, 100점 이하)%n");

        Map<Boolean, Map<Boolean, List<Student2>>> failedStuBySex =
                Stream.of(stuArr).collect(partitioningBy(Student2::isMale,
                        partitioningBy(s -> s.getScore() <= 100))
                );
        List<Student2> failedMaleStu   = failedStuBySex.get(true).get(true);
        List<Student2> failedFemaleStu = failedStuBySex.get(false).get(true);

        for(Student2 s : failedMaleStu)   System.out.println(s);
        for(Student2 s : failedFemaleStu) System.out.println(s);
    }
}

1. 단순분할(성별로 분할)
1-1. 남자만 출력
[나자바, 남, 1학년 1반, 300점]
[김자바, 남, 1학년 1반, 200점]
[남자바, 남, 1학년 2반, 100점]
[이자바, 남, 1학년 3반, 200점]
[나자바, 남, 2학년 1반, 300점]
[김자바, 남, 2학년 1반, 200점]
[남자바, 남, 2학년 2반, 100점]
[이자바, 남, 2학년 3반, 200점]
1-2. 여자만 출력
[김지미, 여, 1학년 1반, 250점]
[이지미, 여, 1학년 2반, 150점]
[안지미, 여, 1학년 2반,  50점]
[황지미, 여, 1학년 3반, 100점]
[강지미, 여, 1학년 3반, 150점]
[김지미, 여, 2학년 1반, 250점]
[이지미, 여, 2학년 2반, 150점]
[안지미, 여, 2학년 2반,  50점]
[황지미, 여, 2학년 3반, 100점]
[강지미, 여, 2학년 3반, 150점]

2. 단순분할 + 통계(성별 학생수)
남학생 수 :8
여학생 수 :10

3. 단순분할 + 통계(성별 1등)
남학생 1등 :Optional[[나자바, 남, 1학년 1반, 300점]]
여학생 1등 :Optional[[김지미, 여, 1학년 1반, 250점]]
남학생 1등 :[나자바, 남, 1학년 1반, 300점]
여학생 1등 :[김지미, 여, 1학년 1반, 250점]

4. 다중분할(성별 불합격자, 100점 이하)
[남자바, 남, 1학년 2반, 100점]
[남자바, 남, 2학년 2반, 100점]
[안지미, 여, 1학년 2반,  50점]
[황지미, 여, 1학년 3반, 100점]
[안지미, 여, 2학년 2반,  50점]
[황지미, 여, 2학년 3반, 100점]
```

### 스트림을 그룹화 - groupingBy()

- 스트림의 요소를 그룹화

```java
package 자바의정석.ch14;

import java.util.*;
import java.util.function.*;
import java.util.stream.*;
import static java.util.stream.Collectors.*;
import static java.util.Comparator.*;

class Student3 {
    String name;
    boolean isMale; // 성별
    int hak;        // 학년
    int ban;        // 반
    int score;

    Student3(String name, boolean isMale, int hak, int ban, int score) {
        this.name	= name;
        this.isMale	= isMale;
        this.hak   	= hak;
        this.ban	= ban;
        this.score 	= score;
    }

    String	getName() 	 { return name;    }
    boolean isMale()  	 { return isMale;  }
    int		getHak()   	 { return hak;	   }
    int		getBan()  	 { return ban;	   }
    int		getScore()	 { return score;   }

    public String toString() {
        return String.format("[%s, %s, %d학년 %d반, %3d점]", name, isMale ? "남" : "여", hak, ban, score);
    }

    enum Level {
        HIGH, MID, LOW
    }
}

class Ex14_11 {
    public static void main(String[] args) {
        Student3[] stuArr = {
                new Student3("나자바", true,  1, 1, 300),
                new Student3("김지미", false, 1, 1, 250),
                new Student3("김자바", true,  1, 1, 200),
                new Student3("이지미", false, 1, 2, 150),
                new Student3("남자바", true,  1, 2, 100),
                new Student3("안지미", false, 1, 2,  50),
                new Student3("황지미", false, 1, 3, 100),
                new Student3("강지미", false, 1, 3, 150),
// 뒷 페이지에 계속됩니다.
                new Student3("이자바", true,  1, 3, 200),
                new Student3("나자바", true,  2, 1, 300),
                new Student3("김지미", false, 2, 1, 250),
                new Student3("김자바", true,  2, 1, 200),
                new Student3("이지미", false, 2, 2, 150),
                new Student3("남자바", true,  2, 2, 100),
                new Student3("안지미", false, 2, 2,  50),
                new Student3("황지미", false, 2, 3, 100),
                new Student3("강지미", false, 2, 3, 150),
                new Student3("이자바", true,  2, 3, 200)
        };

        System.out.printf("1. 단순그룹화(반별로 그룹화)%n");
        Map<Integer, List<Student3>> stuByBan = Stream.of(stuArr)
                .collect(groupingBy(Student3::getBan));

        for(List<Student3> ban : stuByBan.values()) {
            for(Student3 s : ban) {
                System.out.println(s);
            }
        }

        System.out.printf("%n2. 단순그룹화(성적별로 그룹화)%n");
        Map<Student3.Level, List<Student3>> stuByLevel = Stream.of(stuArr)
                .collect(groupingBy(s-> {
                    if(s.getScore() >= 200) return Student3.Level.HIGH;
                    else if(s.getScore() >= 100) return Student3.Level.MID;
                    else                         return Student3.Level.LOW;
                }));

        TreeSet<Student3.Level> keySet = new TreeSet<>(stuByLevel.keySet());

        for(Student3.Level key : keySet) {
            System.out.println("["+key+"]");

            for(Student3 s : stuByLevel.get(key))
                System.out.println(s);
            System.out.println();
        }

        System.out.printf("%n3. 단순그룹화 + 통계(성적별 학생수)%n");
        Map<Student3.Level, Long> stuCntByLevel = Stream.of(stuArr)
                .collect(groupingBy(s-> {
                    if(s.getScore() >= 200) return Student3.Level.HIGH;
                    else if(s.getScore() >= 100) return Student3.Level.MID;
                    else                         return Student3.Level.LOW;
                }, counting()));
        for(Student3.Level key : stuCntByLevel.keySet())
            System.out.printf("[%s] - %d명, ", key, stuCntByLevel.get(key));
        System.out.println();
/*
		for(List<Student3> level : stuByLevel.values()) {
			System.out.println();
			for(Student3 s : level) {
				System.out.println(s);
			}
		}
*/
        System.out.printf("%n4. 다중그룹화(학년별, 반별)");
        Map<Integer, Map<Integer, List<Student3>>> stuByHakAndBan =
                Stream.of(stuArr)
                        .collect(groupingBy(Student3::getHak,
                                groupingBy(Student3::getBan)
                        ));

        for(Map<Integer, List<Student3>> hak : stuByHakAndBan.values()) {
            for(List<Student3> ban : hak.values()) {
                System.out.println();
                for(Student3 s : ban)
                    System.out.println(s);
            }
        }

        System.out.printf("%n5. 다중그룹화 + 통계(학년별, 반별 1등)%n");
        Map<Integer, Map<Integer, Student3>> topStuByHakAndBan =
                Stream.of(stuArr)
                        .collect(groupingBy(Student3::getHak,
                                groupingBy(Student3::getBan,
                                        collectingAndThen(
                                                maxBy(comparingInt(Student3::getScore))
                                                , Optional::get
                                        )
                                )
                        ));

        for(Map<Integer, Student3> ban : topStuByHakAndBan.values())
            for(Student3 s : ban.values())
                System.out.println(s);

        System.out.printf("%n6. 다중그룹화 + 통계(학년별, 반별 성적그룹)%n");
        Map<String, Set<Student3.Level>> stuByScoreGroup = Stream.of(stuArr)
                .collect(groupingBy(s-> s.getHak() + "-" + s.getBan(),
                        mapping(s-> {
                            if(s.getScore() >= 200) return Student3.Level.HIGH;
                            else if(s.getScore() >= 100) return Student3.Level.MID;
                            else                    return Student3.Level.LOW;
                        } , toSet())
                ));

        Set<String> keySet2 = stuByScoreGroup.keySet();

        for(String key : keySet2) {
            System.out.println("["+key+"]" + stuByScoreGroup.get(key));
        }
    }  // main의 끝
}

1. 단순그룹화(반별로 그룹화)
[나자바, 남, 1학년 1반, 300점]
[김지미, 여, 1학년 1반, 250점]
[김자바, 남, 1학년 1반, 200점]
[나자바, 남, 2학년 1반, 300점]
[김지미, 여, 2학년 1반, 250점]
[김자바, 남, 2학년 1반, 200점]
[이지미, 여, 1학년 2반, 150점]
[남자바, 남, 1학년 2반, 100점]
[안지미, 여, 1학년 2반,  50점]
[이지미, 여, 2학년 2반, 150점]
[남자바, 남, 2학년 2반, 100점]
[안지미, 여, 2학년 2반,  50점]
[황지미, 여, 1학년 3반, 100점]
[강지미, 여, 1학년 3반, 150점]
[이자바, 남, 1학년 3반, 200점]
[황지미, 여, 2학년 3반, 100점]
[강지미, 여, 2학년 3반, 150점]
[이자바, 남, 2학년 3반, 200점]

2. 단순그룹화(성적별로 그룹화)
[HIGH]
[나자바, 남, 1학년 1반, 300점]
[김지미, 여, 1학년 1반, 250점]
[김자바, 남, 1학년 1반, 200점]
[이자바, 남, 1학년 3반, 200점]
[나자바, 남, 2학년 1반, 300점]
[김지미, 여, 2학년 1반, 250점]
[김자바, 남, 2학년 1반, 200점]
[이자바, 남, 2학년 3반, 200점]

[MID]
[이지미, 여, 1학년 2반, 150점]
[남자바, 남, 1학년 2반, 100점]
[황지미, 여, 1학년 3반, 100점]
[강지미, 여, 1학년 3반, 150점]
[이지미, 여, 2학년 2반, 150점]
[남자바, 남, 2학년 2반, 100점]
[황지미, 여, 2학년 3반, 100점]
[강지미, 여, 2학년 3반, 150점]

[LOW]
[안지미, 여, 1학년 2반,  50점]
[안지미, 여, 2학년 2반,  50점]

3. 단순그룹화 + 통계(성적별 학생수)
[LOW] - 2명, [MID] - 8명, [HIGH] - 8명, 

4. 다중그룹화(학년별, 반별)
[나자바, 남, 1학년 1반, 300점]
[김지미, 여, 1학년 1반, 250점]
[김자바, 남, 1학년 1반, 200점]

[이지미, 여, 1학년 2반, 150점]
[남자바, 남, 1학년 2반, 100점]
[안지미, 여, 1학년 2반,  50점]

[황지미, 여, 1학년 3반, 100점]
[강지미, 여, 1학년 3반, 150점]
[이자바, 남, 1학년 3반, 200점]

[나자바, 남, 2학년 1반, 300점]
[김지미, 여, 2학년 1반, 250점]
[김자바, 남, 2학년 1반, 200점]

[이지미, 여, 2학년 2반, 150점]
[남자바, 남, 2학년 2반, 100점]
[안지미, 여, 2학년 2반,  50점]

[황지미, 여, 2학년 3반, 100점]
[강지미, 여, 2학년 3반, 150점]
[이자바, 남, 2학년 3반, 200점]

5. 다중그룹화 + 통계(학년별, 반별 1등)
[나자바, 남, 1학년 1반, 300점]
[이지미, 여, 1학년 2반, 150점]
[이자바, 남, 1학년 3반, 200점]
[나자바, 남, 2학년 1반, 300점]
[이지미, 여, 2학년 2반, 150점]
[이자바, 남, 2학년 3반, 200점]

6. 다중그룹화 + 통계(학년별, 반별 성적그룹)
[1-1][HIGH]
[2-1][HIGH]
[1-2][LOW, MID]
[2-2][LOW, MID]
[1-3][MID, HIGH]
[2-3][MID, HIGH]
```
