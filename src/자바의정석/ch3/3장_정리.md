## 연산자와 피연산자

---

연산자는 연산을 수행하는 기호이다.

피연산자는 연산자의 연산 수행 대상이다.

**모든 연산자는 연산 결과를 반환한다!**

| 연산자 종류 | 연산자 | 피연산자 수 | 산출값 | 설명 |
| --- | --- | --- | --- | --- |
| 산술 연산 | +, -, *, /, % | 이항 | 숫자 | 사칙연산 및 나머지계산 한다. |
| 부호 | +, - | 단항 | 숫자 | 음수 / 양수 부호 |
| 문자열 | + | 이항 | 문자 | 두 문자를 연결시킨다. |
| 대입 연산 | =, +=, -=, *=, /=, %=
&=, ^=, |=, <<=, >>=, >>>= | 이항 | 다양 | 우변의 값을 좌변의 변수에 대입 |
| 증감 연산 | ++, -- | 단항 | 숫자 | 1만큼 증가 / 감소 |
| 비교 연산 | ==, !=, <, >, <=, >=,
instanceof | 이항 | boolean | 값의 비교 |
| 논리 연산 | !, &, |, &&, || | 이항
단항 | boolean | 논리적 NOT, AND, OR 연산 |
| 조건 연산 | (조건식) ? A : B | 삼항 | 다양 | 조건식에 따라 참이면 A, 거짓이면 B 선택 |
| 비트 | ~, &, |, ^ | 단항
이항 | 숫자
boolean | 비트 NOT, AND, OR, XOR 연산 |
| 비트 쉬프트 | >>, <<, >>> | 이항 | 숫자 | 비트를 좌 / 우측으로 밀어서 이동 |

### 연산자는 모두 우선순위가 존재한다.

하나의 식에 연산자가 둘 이상 있을때 어떤 연산을 먼저 수행할지를 자동 결정하는 것

기본적으로 우리가 알고 있듯이 곱셈이 먼저이고 하지만 괄호가 있다면 괄호가 먼저이고~ 이런 기본 개념을 알고있다면 상관이 없다.

**딱 세가지만 기억하자!**

1. 산술(+, -) > 비교 > 논리 > 대입 대입은 맨 마지막이다.
2. 단항(1) > 이항(2) > 삼항(3) 단항 연산자의 우선순위가 이항 연산자 보다 높다.
3. 단항 연산자의 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

### 증감 연산자

증가 연산자(++) 피연산자의 값을 1 증가 시킨다.

감소 연산자(—) 피연산자의 값을 1 감소시킨다.

전위형과 후위형이 존재한다.

**❓ 무슨 차이일까?**

- 전위형은 값이 참조되기 전에 증가시킨다.
- 후위형은 값이 참조된 후에 증가시킨다.

**❓ 이게 무슨말이지??**

- 독립적으로 사용할 때는 차이가 없지만 이것을 실제 코드를 예시로 볼때는 다르다.
    
    ```java
    j = ++i // 전위형 i가 1일때 i는 1이 더해지고나서 대입 연산자가 진행되기 때문에 j는 2이다.
    j = i++ // 전위형 i가 1일때 j는 1이고 대입 연산자가 끝나고나서 더해지기 때문에 j는 1이다.
    
    //코드 예시
    public static void main(String[] args) {
        int i = 5, j = 0;
    
        j = i++; // 후위
        System.out.println("후위형 결과 i = " + i + " j = " + j);
        i = 5; j =0;
        j = ++i; // 전위
        System.out.println("전위형 결과 i = " + i + " j = " + j);
    }
    ```
    

### 형변환 연산자

(타입) 피연산자

```java
double d = 85.4;
int score = (int) d; // 85
```

### 자동 형변환

```java
float f = 1234; // int 타입의 값을 float 타입의 변수에 저장
// 아래처럼 자동으로 형변환된다.(컴파일러에서 처리)
float f = (float)1234;

int i = 3.14f // 에러 float이 int보다 크기 때문이다. 즉 값손실이 나기 때문에 컴파일러가 자동형변환 해주지 못한다.
int i = (int)3.14f; // 직접 수동 형변환 해줘야 한다.
```

즉 작은 그릇을 큰 그릇으로 바꾸는건 자동으로 해주지만 큰 그릇을 작은 그릇으로 바꾸는 경우에는 수동으로 해줘야한다.

작은 그릇 → 큰 그릇 (byte → int)

큰 그릇 → 작은 그릇(int → byte)

**큰 그릇에서 작은 그릇으로 옮기면 값 손실이 있을 수 있다.**

### 형변환을 생략하면 컴파일러가 자동적으로 형 변환한다.

**기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환 된다**

byte상으로만 따지면 안된다. long은 10^19지만 float은 10^38이기 때문에 long → float은 되지만 float → long은 형변환을 생략해서는 안된다.

### 산술 변환

연산 전에 피연산자의 타입을 일치시키는 것을 말한다.

1. **두 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치)**
    
    **→ 값 손실을 최소화하기 위해서**
    
    long + int  → long + long 
    
    float + int → float + float
    
    double + float → double + double
    
2. **int보다 작은 타입이면 int로 변환된다.**
    
    byte + short → int + int 
    
    char + short → int + int
    

### 반올림 - Math.rount()

실수를 소수점 첫 째자리에서 반올림한 정수를 반환

```java
long result = Math.round(4.52); // result에는 5가 저장된다.
```

```java
public class Ex3_11 {
    public static void main(String[] args) {
        double pi = 3.141592;
        double shortPi = Math.round(pi * 1000) / 1000.0;
        System.out.println("shortPi = " + shortPi);
    }
}
```

→ Math.round(3.141592 * 1000) / 1000.0

→ Math.round(3142.592) / 1000.0

→ 3142 / 1000.0 → int / double → double / double

→ 3142.0 / 1000.0 → 3.142

### 나머지 연산자 %

```java
int x = 10;
int y = 8;

System.out.printf("%d을 %d로 나누면 %n", x, y);
System.out.printf("몫은 %d이고, 나머지는 %d입니다. %n", x / y, x % y);
// 출력 결과
// 10을 8로 나누면 
// 몫은 1이고, 나머지는 2입니다.
```

### 비교 연산자

| 구분 | 연산식 | 설명 |
| --- | --- | --- |
| 동등비교 | == | 두 피 연산자의 값이 같은지를 검사 |
| 동등비교 | ≠ | 두 피 연산자의 값이 다른지를 검사 |
| 크기비교 | > | 피 연산자1이 큰지를 검사 |
| 크기비교 | ≥ | 피 연산자1이 크거나 같은지를 검사 |
| 크기비교 | < | 피 연산자1이 작은지를 검사 |
| 크기비교 | ≤ | 피 연산자1이 작거나 같은지를 검사 |

### 문자열 비교

문자열 비교에서는 == 대신 equals()를 사용한다.

**이후에 추가적인 설명 예정**

### 논리 연산자

|| (OR결합) 피연산자 중 어느 한 쪽이 true이면 true를 결과로 얻는다

&& (AND결합) 피연산자 양쪽 모두 true이여야 true를 결과로 얻는다.

코드 예시는 내가 자바알고리즘 문제 풀었던 내용들에서 보았다.

### 논리 부정 연산자

true를 flase로 false는 true로 바꾼다.

```java
boolean b = true;
// !!b → !!true → !false → true
```

### 조건 연산자 ? :

조건식 ? 식1: 식 2

true이면 식1 false면 식2가 나온다.

```java
result = x > y ? x : y; 
// true 이면 x false 이면 y
if(x > y)
	result = x;
else 
	result = y;
```

### 대입 연산자 =

오른쪽 피연산자를 왼쪽 피연산자에 저장 후 저장된 값을 반환

```java
x = 3; // 변수 x에 3이 저장된다.
x = y = 3; //는 오른쪽에서 왼쪽으로 저장된다.
```

### 복합 대입 연산자

| 복합 대입 연산자 | 설명 |
| --- | --- |
| += | 왼쪽의 피연산자에 오른쪽의 피연산자를 더한 후, 왼쪽의 피연산자에 대입함. |
| -= | 왼쪽의 피연산자에서 오른쪽의 피연산자를 뺀 후, 왼쪽의 피연산자에 대입함. |
| *= | 왼쪽의 피연산자에 오른쪽의 피연산자를 곱한 후, 왼쪽의 피연산자에 대입함. |
| /= | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 왼쪽의 피연산자에 대입함. |
| %= | 왼쪽의 피연산자를 오른쪽의 피연산자로 나눈 후, 그 나머지를 왼쪽의 피연산자에 대입함. |
| .= | 왼쪽 피연산자의 문자열에 오른쪽 피연산자의 문자열을 추가한 후, 왼쪽의 피연산자에 대입함. |
| <<= | 왼쪽의 피연산자의 비트를 오른쪽의 피연산자만큼 전부 왼쪽으로 이동시킨 후, 그 결과를 왼쪽의 피연산자에 대입함 |
| >>= | 왼쪽의 피연산자의 비트를 부호를 유지하면서 오른쪽의 피연산자만큼 전부 오른쪽으로 이동시킨 후, 그 결과를 왼쪽의 피연산자에 대입함. |
| &= | 왼쪽의 피연산자와 오른쪽의 피연산자의 논리식이 모두 true면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함. |
| |= | 왼쪽의 피연산자나 오른쪽의 피연산자의 논리식 중 하나라도 true면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함. |
| ^= | 왼쪽 피연산자의 논리식과 오른쪽 피연산자의 논리식이 서로 다르면 왼쪽 피연산자에 true을 대입하고, 그 외에는 false을 대입함 |
